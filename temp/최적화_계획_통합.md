# 엑셀 분석기 코드베이스 최적화 계획

## 1. 성능 병목 및 최적화 포인트

### 1.1 데이터 로딩 최적화
- **중복 코드**: src/core/data_loader.py와 src/data/data_loader.py에 유사한 코드가 중복 존재
- **최적화 방안**:
  - 두 DataLoader 클래스를 통합하여 하나의 표준 구현체로 관리
  - 대용량 파일 처리 시 메모리 효율적인 청크 단위 로딩 패턴 강화
  - 경로 처리에서 문자열과 Path 객체 혼용 개선 (일관된 pathlib 기반 구현)

### 1.2 메모리 사용량 최적화
- **현재 구현**: _optimize_dataframe() 메서드로 데이터 타입 최적화 수행 중
- **개선 방안**:
  - 최적화 로직을 모듈화하여 재사용성 높이기
  - 매우 큰 데이터셋에 대한 지연 처리(lazy evaluation) 메커니즘 도입
  - 불필요한 데이터프레임 복사 최소화 (df.copy() 사용 최적화)

### 1.3 GUI 반응성 개선
- **문제점**: nalysis_view.py의 테이블 모델 처리 코드가 복잡하고 무거움
- **최적화 방안**:
  - 대규모 데이터 표시 시 가상화(virtualization) 기법 적용
  - 비동기 처리로 UI 스레드 차단 최소화
  - 불필요한 layoutChanged.emit() 호출 최적화

## 2. 중복 코드 및 리팩토링 필요 부분

### 2.1 중복 기능 구현
- src/core/analysis_engine.py와 src/core/query_engine.py에 유사한 그룹화 및 집계 기능 중복
- VisualizationEngine 클래스 내 여러 그래프 생성 메서드에서 데이터프레임 검증 코드 반복
- 다양한 클래스에서 유사한 로깅 초기화 및 오류 처리 패턴 중복

### 2.2 리팩토링 제안
- 공통 유틸리티 모듈로 중복 기능 추출:
  - 데이터프레임 검증 및 전처리 유틸리티
  - 로깅 및 오류 처리 표준화
  - 파일 I/O 작업 통합

### 2.3 테스트 코드 개선
- 테스트용 스텁 클래스 대신 표준 모킹 라이브러리 활용
- 단위 테스트 커버리지 확대

## 3. 불필요한 코드 및 최적화 우선순위

### 3.1 제거 검토 대상
- 중복 구현된 DataLoader 클래스 중 하나
- 특수 케이스 처리를 위한 불필요하게 복잡한 분기 로직
- 불필요한 중간 결과 저장

### 3.2 최적화 우선순위
1. **데이터 로딩 최적화** - 대용량 데이터 처리 핵심 기능
2. **메모리 사용 효율화** - 큰 데이터셋 처리 능력 향상
3. **GUI 응답성 개선** - 사용자 경험 향상
4. **중복 코드 통합** - 유지보수성 개선
5. **테스트 커버리지 확대** - 안정성 개선

## 4. 구체적인 개선 계획

### 4.1 단기 개선 (1-2주)
- 중복 DataLoader 통합
- 데이터프레임 최적화 로직 개선
- 불필요한 로깅 및 디버깅 코드 정리

### 4.2 중기 개선 (3-4주)
- 비동기 처리를 통한 GUI 응답성 개선
- 그래프 생성 로직 모듈화 및 효율화
- 유틸리티 모듈 구축 및 중복 코드 제거

### 4.3 장기 개선 (1-2개월)
- 테스트 커버리지 확대
- 성능 프로파일링 기반 추가 최적화
- 메모리 사용량 추적 및 개선 메커니즘 구축

## 5. 결론

엑셀 분석기 코드베이스는 전반적으로 잘 구성되어 있으나, 중복 코드와 최적화 가능성이 있는 부분들이 다수 존재합니다. 위 계획을 단계적으로 적용하면 성능, 메모리 사용량, 유지보수성 측면에서 상당한 개선이 가능할 것으로 예상됩니다.

## 6. 리스크 평가 및 완화 방안

### 6.1 리스크 평가

1. **데이터 로딩 최적화 (리스크: 높음)**
   - 두 DataLoader 클래스 통합 시 기존 코드와의 의존성 문제 발생
   - 기존 API 변경으로 사용 중인 다른 모듈에 영향
   - 대용량 파일 처리 패턴 변경 시 예상치 못한 메모리 문제 발생 가능성

2. **메모리 사용량 최적화 (리스크: 중간)**
   - 데이터 타입 최적화 과정에서 정밀도 손실 가능성
   - 지연 처리 도입 시 기존 즉시 실행 코드와의 호환성 문제
   - 복사 최소화 작업 중 참조 오류 위험

3. **GUI 반응성 개선 (리스크: 중간~높음)**
   - 비동기 처리 도입 시 경쟁 상태(race condition) 발생 가능
   - UI 스레드와 작업 스레드 간 동기화 문제
   - 가상화 구현 시 데이터 표시 오류 가능성

4. **중복 코드 통합 (리스크: 중간)**
   - 공통 유틸리티로 추출 시 특수 사례 처리 누락 가능성
   - 테스트 커버리지가 낮은 영역 변경 시 버그 발생 위험

### 6.2 리스크 완화 방안

1. **단계적 구현 및 테스트**
   - 각 최적화를 작은 단위로 나누어 점진적으로 적용
   - 변경 후 즉시 회귀 테스트 수행

2. **백업 및 롤백 계획**
   - 각 단계별 변경 전 코드 백업
   - 문제 발생 시 빠른 롤백 가능하도록 준비

3. **테스트 커버리지 확대**
   - 최적화 전 자동화 테스트 케이스 추가
   - 특히 성능 중심 코드의 경우 부하 테스트 필수

4. **점진적 배포**
   - 변경사항을 프로덕션에 즉시 적용하지 않고 테스트 환경에서 충분히 검증

전체적으로 30-40% 정도의 리스크가 있지만, 체계적인 접근으로 대부분 관리 가능합니다.